// SPDX-FileCopyrightText: 2025 RAprogramm <andrey.rozanov.vl@gmail.com>
// SPDX-License-Identifier: MIT

//! Attribute parsing for the Entity derive macro.
//!
//! This module handles extraction of entity metadata from Rust attributes.
//! It uses [`darling`] for entity-level attributes and manual parsing for
//! field-level attributes (which use marker-style syntax).
//!
//! # Parsing Strategy
//!
//! Entity-level attributes like `#[entity(table = "users", schema = "core")]`
//! are parsed using darling's `FromDeriveInput` derive macro, which provides:
//!
//! - Automatic validation of required fields
//! - Default values for optional fields
//! - Clear error messages for invalid input
//!
//! Field-level attributes like `#[id]`, `#[auto]`, and `#[field(create,
//! update)]` use manual parsing because they're marker attributes that don't
//! fit darling's key-value model well.
//!
//! # Data Structures
//!
//! ```text
//! EntityDef
//! ├── ident: Ident          (struct name, e.g., "User")
//! ├── vis: Visibility       (pub, pub(crate), etc.)
//! ├── table: String         (database table name)
//! ├── schema: String        (database schema)
//! ├── sql: SqlLevel         (generation level)
//! └── fields: Vec<FieldDef>
//!     └── FieldDef
//!         ├── ident: Ident      (field name)
//!         ├── ty: Type          (field type)
//!         ├── vis: Visibility   (field visibility)
//!         ├── is_id: bool       (#[id] present)
//!         ├── is_auto: bool     (#[auto] present)
//!         ├── create: bool      (in CreateRequest)
//!         ├── update: bool      (in UpdateRequest)
//!         ├── response: bool    (in Response)
//!         └── skip: bool        (excluded from DTOs)
//! ```
//!
//! # Examples
//!
//! ## Basic Parsing
//!
//! ```rust,ignore
//! #[derive(Entity)]
//! #[entity(table = "users")]
//! pub struct User {
//!     #[id]
//!     pub id: Uuid,
//!
//!     #[field(create, response)]
//!     pub name: String,
//! }
//!
//! // Parses to:
//! // EntityDef {
//! //     ident: "User",
//! //     table: "users",
//! //     schema: "public",  // default
//! //     sql: SqlLevel::Full,  // default
//! //     fields: [
//! //         FieldDef { ident: "id", is_id: true, ... },
//! //         FieldDef { ident: "name", create: true, response: true, ... },
//! //     ]
//! // }
//! ```
//!
//! ## Custom Schema and SQL Level
//!
//! ```rust,ignore
//! #[derive(Entity)]
//! #[entity(table = "products", schema = "inventory", sql = "trait")]
//! pub struct Product { /* ... */ }
//!
//! // Parses to:
//! // EntityDef {
//! //     table: "products",
//! //     schema: "inventory",
//! //     sql: SqlLevel::Trait,
//! //     ...
//! // }
//! ```

mod dialect;

use convert_case::{Case, Casing};
use darling::{FromDeriveInput, FromMeta};
pub use dialect::DatabaseDialect;
use proc_macro2::Span;
use syn::{Attribute, DeriveInput, Field, Ident, Meta, Type, Visibility};

/// SQL generation level for the entity.
///
/// Controls how much database-related code is generated by the macro.
/// This allows flexibility between fully automated generation and
/// manual control over SQL queries.
///
/// # Variants
///
/// | Level | Repository Trait | PgPool Impl | Row/Insertable |
/// |-------|-----------------|-------------|----------------|
/// | `Full` | Yes | Yes | Yes |
/// | `Trait` | Yes | No | Yes |
/// | `None` | No | No | No |
///
/// # Examples
///
/// ```rust,ignore
/// // Full generation (default) - everything automated
/// #[entity(table = "users")]
/// #[entity(table = "users", sql = "full")]
///
/// // Trait only - implement SQL yourself for complex queries
/// #[entity(table = "users", sql = "trait")]
///
/// // None - only DTOs, no database layer
/// #[entity(table = "users", sql = "none")]
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum SqlLevel {
    /// Generate repository trait AND implementation for `PgPool`.
    ///
    /// This is the default level, providing complete CRUD operations
    /// with standard SQL queries. Best for simple entities without
    /// complex query requirements.
    #[default]
    Full,

    /// Generate only the repository trait definition.
    ///
    /// Use this when you need custom SQL queries (joins, CTEs,
    /// full-text search, etc.) but still want the trait interface
    /// and other generated types.
    Trait,

    /// Skip all repository generation.
    ///
    /// Only DTOs are generated. Use this for entities that don't
    /// need database persistence or use a completely different
    /// storage mechanism.
    None
}

impl FromMeta for SqlLevel {
    /// Parse SQL level from string attribute value.
    ///
    /// # Accepted Values
    ///
    /// - `"full"` → [`SqlLevel::Full`]
    /// - `"trait"` → [`SqlLevel::Trait`]
    /// - `"none"` → [`SqlLevel::None`]
    ///
    /// Values are case-insensitive.
    ///
    /// # Errors
    ///
    /// Returns `darling::Error::unknown_value` for unrecognized values.
    fn from_string(value: &str) -> darling::Result<Self> {
        match value.to_lowercase().as_str() {
            "full" => Ok(SqlLevel::Full),
            "trait" => Ok(SqlLevel::Trait),
            "none" => Ok(SqlLevel::None),
            _ => Err(darling::Error::unknown_value(value))
        }
    }
}

/// Entity-level attributes parsed from `#[entity(...)]`.
///
/// This is an internal struct used by darling for parsing.
/// The public API uses [`EntityDef`] which combines these
/// attributes with parsed field definitions.
#[derive(Debug, FromDeriveInput)]
#[darling(attributes(entity), supports(struct_named))]
struct EntityAttrs {
    /// Struct identifier (e.g., `User`).
    ident: Ident,

    /// Struct visibility (e.g., `pub`, `pub(crate)`).
    vis: Visibility,

    /// Database table name.
    ///
    /// This is a required attribute with no default value.
    /// The macro will fail with a clear error if not provided.
    table: String,

    /// Database schema name.
    ///
    /// Defaults to `"public"` if not specified.
    #[darling(default = "default_schema")]
    schema: String,

    /// SQL generation level.
    ///
    /// Defaults to [`SqlLevel::Full`] if not specified.
    #[darling(default)]
    sql: SqlLevel,

    /// Database dialect.
    ///
    /// Defaults to [`DatabaseDialect::Postgres`] if not specified.
    #[darling(default)]
    dialect: DatabaseDialect
}

/// Returns the default schema name.
///
/// Used by darling for the `schema` attribute default.
fn default_schema() -> String {
    "public".to_string()
}

/// Complete parsed entity definition.
///
/// This is the main data structure passed to all code generators.
/// It contains both entity-level metadata and all field definitions.
///
/// # Construction
///
/// Create via [`EntityDef::from_derive_input`]:
///
/// ```rust,ignore
/// let entity = EntityDef::from_derive_input(&input)?;
/// ```
///
/// # Field Access
///
/// Use the provided methods to access fields by category:
///
/// ```rust,ignore
/// // All fields for Row/Insertable
/// let all = entity.all_fields();
///
/// // Fields for specific DTOs
/// let create_fields = entity.create_fields();
/// let update_fields = entity.update_fields();
/// let response_fields = entity.response_fields();
///
/// // Primary key field
/// let id = entity.id_field().expect("must have #[id]");
/// ```
#[derive(Debug)]
pub struct EntityDef {
    /// Struct identifier (e.g., `User`).
    pub ident: Ident,

    /// Struct visibility.
    ///
    /// Propagated to all generated types so they have the same
    /// visibility as the source entity.
    pub vis: Visibility,

    /// Database table name (e.g., `"users"`).
    pub table: String,

    /// Database schema name (e.g., `"public"`, `"core"`).
    pub schema: String,

    /// SQL generation level controlling what code is generated.
    pub sql: SqlLevel,

    /// Database dialect for code generation.
    pub dialect: DatabaseDialect,

    /// All field definitions from the struct.
    pub fields: Vec<FieldDef>
}

impl EntityDef {
    /// Parse entity definition from syn's `DeriveInput`.
    ///
    /// This is the main entry point for parsing. It:
    ///
    /// 1. Parses entity-level attributes using darling
    /// 2. Extracts all named fields from the struct
    /// 3. Parses field-level attributes for each field
    /// 4. Combines everything into an `EntityDef`
    ///
    /// # Arguments
    ///
    /// * `input` - Parsed derive input from syn
    ///
    /// # Returns
    ///
    /// `Ok(EntityDef)` on success, or `Err` with darling errors.
    ///
    /// # Errors
    ///
    /// - Missing `table` attribute
    /// - Applied to non-struct (enum, union)
    /// - Applied to tuple struct or unit struct
    /// - Invalid attribute values
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// pub fn derive(input: TokenStream) -> TokenStream {
    ///     let input = parse_macro_input!(input as DeriveInput);
    ///
    ///     match EntityDef::from_derive_input(&input) {
    ///         Ok(entity) => generate(entity),
    ///         Err(err) => err.write_errors().into()
    ///     }
    /// }
    /// ```
    pub fn from_derive_input(input: &DeriveInput) -> darling::Result<Self> {
        let attrs = EntityAttrs::from_derive_input(input)?;

        let fields = match &input.data {
            syn::Data::Struct(data) => match &data.fields {
                syn::Fields::Named(named) => {
                    named.named.iter().map(FieldDef::from_field).collect()
                }
                _ => {
                    return Err(darling::Error::custom("Entity requires named fields")
                        .with_span(&input.ident));
                }
            },
            _ => {
                return Err(
                    darling::Error::custom("Entity can only be derived for structs")
                        .with_span(&input.ident)
                );
            }
        };

        Ok(Self {
            ident: attrs.ident,
            vis: attrs.vis,
            table: attrs.table,
            schema: attrs.schema,
            sql: attrs.sql,
            dialect: attrs.dialect,
            fields
        })
    }

    /// Get the primary key field marked with `#[id]`.
    ///
    /// # Returns
    ///
    /// `Some(&FieldDef)` if an `#[id]` field exists, `None` otherwise.
    ///
    /// # Note
    ///
    /// Most generators require an id field. The SQL generator will
    /// panic if called without one. Consider validating this in
    /// `from_derive_input` for better error messages.
    pub fn id_field(&self) -> Option<&FieldDef> {
        self.fields.iter().find(|f| f.is_id)
    }

    /// Get fields to include in `CreateRequest` DTO.
    ///
    /// Returns fields where:
    /// - `#[field(create)]` is present
    /// - NOT marked with `#[id]` (IDs are auto-generated)
    /// - NOT marked with `#[auto]` (timestamps are auto-generated)
    /// - NOT marked with `#[field(skip)]`
    ///
    /// # Returns
    ///
    /// Vector of field references for the create DTO.
    pub fn create_fields(&self) -> Vec<&FieldDef> {
        self.fields
            .iter()
            .filter(|f| f.in_create() && !f.is_id && !f.is_auto)
            .collect()
    }

    /// Get fields to include in `UpdateRequest` DTO.
    ///
    /// Returns fields where:
    /// - `#[field(update)]` is present
    /// - NOT marked with `#[id]` (can't update primary key)
    /// - NOT marked with `#[auto]` (timestamps auto-update)
    /// - NOT marked with `#[field(skip)]`
    ///
    /// # Returns
    ///
    /// Vector of field references for the update DTO.
    pub fn update_fields(&self) -> Vec<&FieldDef> {
        self.fields
            .iter()
            .filter(|f| f.in_update() && !f.is_id && !f.is_auto)
            .collect()
    }

    /// Get fields to include in `Response` DTO.
    ///
    /// Returns fields where:
    /// - `#[field(response)]` is present, OR
    /// - `#[id]` is present (IDs always in response)
    /// - NOT marked with `#[field(skip)]`
    ///
    /// # Returns
    ///
    /// Vector of field references for the response DTO.
    pub fn response_fields(&self) -> Vec<&FieldDef> {
        self.fields.iter().filter(|f| f.in_response()).collect()
    }

    /// Get all fields for Row and Insertable structs.
    ///
    /// These database-layer structs include ALL fields from the
    /// entity, regardless of DTO inclusion settings.
    ///
    /// # Returns
    ///
    /// Slice of all field definitions.
    pub fn all_fields(&self) -> &[FieldDef] {
        &self.fields
    }

    /// Get the entity name as an identifier.
    ///
    /// # Returns
    ///
    /// Reference to the struct's `Ident`.
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// let entity_name = entity.name(); // e.g., Ident("User")
    /// quote! { impl #entity_name { } }
    /// ```
    pub fn name(&self) -> &Ident {
        &self.ident
    }

    /// Get the entity name as a string.
    ///
    /// # Returns
    ///
    /// String representation of the entity name.
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// entity.name_str() // "User"
    /// ```
    pub fn name_str(&self) -> String {
        self.ident.to_string()
    }

    /// Get the entity name in snake_case.
    ///
    /// Useful for generating function names, variable names, etc.
    ///
    /// # Returns
    ///
    /// Snake case version of the entity name.
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// entity.snake_name() // "user", "user_profile", "order_item"
    /// ```
    #[allow(dead_code)]
    pub fn snake_name(&self) -> String {
        self.name_str().to_case(Case::Snake)
    }

    /// Get the fully qualified table name with schema.
    ///
    /// # Returns
    ///
    /// String in format `"schema.table"`.
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// entity.full_table_name() // "core.users", "public.products"
    /// ```
    pub fn full_table_name(&self) -> String {
        format!("{}.{}", self.schema, self.table)
    }

    /// Create a new identifier with prefix and/or suffix.
    ///
    /// Used to generate related type names following naming conventions.
    ///
    /// # Arguments
    ///
    /// * `prefix` - String to prepend (e.g., `"Create"`, `"Insertable"`)
    /// * `suffix` - String to append (e.g., `"Request"`, `"Row"`)
    ///
    /// # Returns
    ///
    /// New `Ident` at `call_site` span.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// // For entity "User":
    /// entity.ident_with("Create", "Request") // CreateUserRequest
    /// entity.ident_with("Update", "Request") // UpdateUserRequest
    /// entity.ident_with("", "Response")      // UserResponse
    /// entity.ident_with("", "Row")           // UserRow
    /// entity.ident_with("Insertable", "")    // InsertableUser
    /// entity.ident_with("", "Repository")    // UserRepository
    /// ```
    pub fn ident_with(&self, prefix: &str, suffix: &str) -> Ident {
        Ident::new(
            &format!("{}{}{}", prefix, self.name_str(), suffix),
            Span::call_site()
        )
    }
}

/// Field definition with all parsed attributes.
///
/// Represents a single field from the entity struct, including
/// all metadata extracted from attributes.
///
/// # Attribute Flags
///
/// | Field | Attribute | Effect |
/// |-------|-----------|--------|
/// | `is_id` | `#[id]` | Primary key, auto-generated UUID |
/// | `is_auto` | `#[auto]` | Auto-generated (timestamps) |
/// | `create` | `#[field(create)]` | Include in CreateRequest |
/// | `update` | `#[field(update)]` | Include in UpdateRequest |
/// | `response` | `#[field(response)]` | Include in Response |
/// | `skip` | `#[field(skip)]` | Exclude from all DTOs |
#[derive(Debug)]
pub struct FieldDef {
    /// Field identifier (e.g., `id`, `name`, `created_at`).
    pub ident: Ident,

    /// Field type (e.g., `Uuid`, `Option<String>`, `DateTime<Utc>`).
    pub ty: Type,

    /// Field visibility.
    ///
    /// Preserved for potential future use in generated code.
    #[allow(dead_code)]
    pub vis: Visibility,

    /// Whether this is the primary key field (`#[id]`).
    ///
    /// ID fields:
    /// - Get auto-generated UUIDs in `From<CreateRequest>`
    /// - Are always included in Response DTOs
    /// - Are excluded from CreateRequest and UpdateRequest
    pub is_id: bool,

    /// Whether this field is auto-generated (`#[auto]`).
    ///
    /// Auto fields (typically timestamps):
    /// - Get `Default::default()` in `From<CreateRequest>`
    /// - Are excluded from CreateRequest and UpdateRequest
    /// - Can still be included in Response
    pub is_auto: bool,

    /// Include in `CreateRequest` DTO.
    pub create: bool,

    /// Include in `UpdateRequest` DTO.
    pub update: bool,

    /// Include in `Response` DTO.
    pub response: bool,

    /// Exclude from all DTOs.
    ///
    /// Overrides `create`, `update`, and `response` flags.
    /// Use for internal fields like password hashes.
    pub skip: bool
}

impl FieldDef {
    /// Parse field definition from syn's `Field`.
    ///
    /// Extracts the field identifier, type, visibility, and all
    /// attribute flags.
    ///
    /// # Arguments
    ///
    /// * `field` - Parsed field from syn
    ///
    /// # Returns
    ///
    /// Populated `FieldDef` with all attributes parsed.
    ///
    /// # Panics
    ///
    /// Panics if the field doesn't have an identifier (tuple struct field).
    /// This should be caught earlier by darling's `supports(struct_named)`.
    fn from_field(field: &Field) -> Self {
        let ident = field.ident.clone().expect("named field required");
        let ty = field.ty.clone();
        let vis = field.vis.clone();

        let mut is_id = false;
        let mut is_auto = false;
        let mut create = false;
        let mut update = false;
        let mut response = false;
        let mut skip = false;

        for attr in &field.attrs {
            if attr.path().is_ident("id") {
                is_id = true;
            } else if attr.path().is_ident("auto") {
                is_auto = true;
            } else if attr.path().is_ident("field") {
                parse_field_attr(attr, &mut create, &mut update, &mut response, &mut skip);
            }
        }

        Self {
            ident,
            ty,
            vis,
            is_id,
            is_auto,
            create,
            update,
            response,
            skip
        }
    }

    /// Get the field name as an identifier.
    ///
    /// # Returns
    ///
    /// Reference to the field's `Ident`.
    pub fn name(&self) -> &Ident {
        &self.ident
    }

    /// Get the field name as a string.
    ///
    /// Used for generating SQL column names.
    ///
    /// # Returns
    ///
    /// String representation of the field name.
    pub fn name_str(&self) -> String {
        self.ident.to_string()
    }

    /// Check if field should be in `CreateRequest`.
    ///
    /// Returns `true` if `create` is set AND `skip` is NOT set.
    pub fn in_create(&self) -> bool {
        !self.skip && self.create
    }

    /// Check if field should be in `UpdateRequest`.
    ///
    /// Returns `true` if `update` is set AND `skip` is NOT set.
    pub fn in_update(&self) -> bool {
        !self.skip && self.update
    }

    /// Check if field should be in `Response`.
    ///
    /// Returns `true` if:
    /// - `response` is set, OR `is_id` is true (IDs always in response)
    /// - AND `skip` is NOT set
    pub fn in_response(&self) -> bool {
        !self.skip && (self.response || self.is_id)
    }

    /// Check if the field type is `Option<T>`.
    ///
    /// Used to determine whether to wrap update fields in `Option`.
    /// If a field is already `Option`, it stays as-is in UpdateRequest.
    /// Non-option fields become `Option<T>` for partial updates.
    ///
    /// # Returns
    ///
    /// `true` if the type path ends with `Option`.
    ///
    /// # Limitations
    ///
    /// This is a simple heuristic that checks the last path segment.
    /// It may give false positives for custom types named `Option`.
    pub fn is_option(&self) -> bool {
        if let Type::Path(type_path) = &self.ty
            && let Some(segment) = type_path.path.segments.last()
        {
            return segment.ident == "Option";
        }
        false
    }

    /// Get the field type.
    ///
    /// # Returns
    ///
    /// Reference to the field's `Type`.
    pub fn ty(&self) -> &Type {
        &self.ty
    }
}

/// Parse `#[field(create, update, response, skip)]` attribute.
///
/// Extracts boolean flags from the nested meta list. Each identifier
/// in the list sets the corresponding flag to `true`.
///
/// # Arguments
///
/// * `attr` - The attribute to parse
/// * `create` - Mutable reference to create flag
/// * `update` - Mutable reference to update flag
/// * `response` - Mutable reference to response flag
/// * `skip` - Mutable reference to skip flag
///
/// # Recognized Identifiers
///
/// - `create` → sets `*create = true`
/// - `update` → sets `*update = true`
/// - `response` → sets `*response = true`
/// - `skip` → sets `*skip = true`
///
/// Unknown identifiers are silently ignored for forward compatibility.
///
/// # Examples
///
/// ```rust,ignore
/// #[field(create, response)]     // create=true, response=true
/// #[field(update)]               // update=true
/// #[field(skip)]                 // skip=true (overrides others)
/// #[field(create, update, response)] // all three true
/// ```
fn parse_field_attr(
    attr: &Attribute,
    create: &mut bool,
    update: &mut bool,
    response: &mut bool,
    skip: &mut bool
) {
    if let Meta::List(meta_list) = &attr.meta {
        let _ = meta_list.parse_nested_meta(|meta| {
            if meta.path.is_ident("create") {
                *create = true;
            } else if meta.path.is_ident("update") {
                *update = true;
            } else if meta.path.is_ident("response") {
                *response = true;
            } else if meta.path.is_ident("skip") {
                *skip = true;
            }
            Ok(())
        });
    }
}
