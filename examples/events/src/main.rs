// SPDX-FileCopyrightText: 2025-2026 RAprogramm <andrey.rozanov.vl@gmail.com>
// SPDX-License-Identifier: MIT

//! Events Example with entity-derive
//!
//! Demonstrates lifecycle events:
//! - `#[entity(events)]` generates event enum
//! - Events for Created, Updated, Deleted
//! - Event handling for audit logging

use std::sync::Arc;

use axum::{
    Json, Router,
    extract::{Path, State},
    http::StatusCode,
    response::IntoResponse,
    routing::{get, post}
};
use chrono::{DateTime, Utc};
use entity_derive::Entity;
use serde::Deserialize;
use sqlx::PgPool;
use tokio::sync::broadcast;
use uuid::Uuid;

// ============================================================================
// Entity Definition with Events
// ============================================================================

/// Order entity with lifecycle events.
#[derive(Debug, Clone, Entity)]
#[entity(table = "orders", events)]
pub struct Order {
    #[id]
    pub id: Uuid,

    #[field(create, update, response)]
    pub customer_name: String,

    #[field(create, update, response)]
    pub product: String,

    #[field(create, update, response)]
    pub quantity: i32,

    #[field(create, update, response)]
    pub status: String,

    #[field(response)]
    #[auto]
    pub created_at: DateTime<Utc>,

    #[field(response)]
    #[auto]
    pub updated_at: DateTime<Utc>
}

// Generated by macro:
// pub enum OrderEvent {
//     Created(Order),
//     Updated { old: Order, new: Order },
//     HardDeleted { id: Uuid },
// }

// ============================================================================
// Application State
// ============================================================================

#[derive(Clone)]
struct AppState {
    pool:   Arc<PgPool>,
    events: broadcast::Sender<String>
}

// ============================================================================
// Event Handler
// ============================================================================

/// Process order events for audit logging.
fn handle_event(event: &OrderEvent) -> String {
    match event {
        OrderEvent::Created(order) => {
            format!(
                "[AUDIT] Order created: id={}, customer={}, product={}",
                order.id, order.customer_name, order.product
            )
        }
        OrderEvent::Updated {
            old,
            new
        } => {
            let mut changed = Vec::new();
            if old.customer_name != new.customer_name {
                changed.push("customer_name");
            }
            if old.product != new.product {
                changed.push("product");
            }
            if old.quantity != new.quantity {
                changed.push("quantity");
            }
            if old.status != new.status {
                changed.push("status");
            }
            format!(
                "[AUDIT] Order updated: id={}, changed={:?}",
                new.id, changed
            )
        }
        OrderEvent::HardDeleted {
            id
        } => {
            format!("[AUDIT] Order deleted: id={}", id)
        }
    }
}

// ============================================================================
// HTTP Handlers
// ============================================================================

#[derive(Deserialize)]
struct CreateOrder {
    customer_name: String,
    product:       String,
    quantity:      i32
}

async fn create_order(
    State(state): State<AppState>,
    Json(input): Json<CreateOrder>
) -> Result<impl IntoResponse, StatusCode> {
    let dto = CreateOrderRequest {
        customer_name: input.customer_name,
        product:       input.product,
        quantity:      input.quantity,
        status:        "pending".to_string()
    };

    let order = OrderRepository::create(&*state.pool, dto)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    // Emit event
    let event = OrderEvent::created(order.clone());
    let log = handle_event(&event);
    tracing::info!("{}", log);
    let _ = state.events.send(log);

    Ok((StatusCode::CREATED, Json(OrderResponse::from(order))))
}

async fn update_order(
    State(state): State<AppState>,
    Path(id): Path<Uuid>,
    Json(dto): Json<UpdateOrderRequest>
) -> Result<impl IntoResponse, StatusCode> {
    // Fetch old state before update
    let old = OrderRepository::find_by_id(&*state.pool, id)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
        .ok_or(StatusCode::NOT_FOUND)?;

    // Perform update
    let new = OrderRepository::update(&*state.pool, id, dto)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    // Emit event with old and new state
    let event = OrderEvent::updated(old, new.clone());
    let log = handle_event(&event);
    tracing::info!("{}", log);
    let _ = state.events.send(log);

    Ok(Json(OrderResponse::from(new)))
}

async fn delete_order(
    State(state): State<AppState>,
    Path(id): Path<Uuid>
) -> Result<impl IntoResponse, StatusCode> {
    let deleted = OrderRepository::delete(&*state.pool, id)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    if deleted {
        // Emit event
        let event = OrderEvent::hard_deleted(id);
        let log = handle_event(&event);
        tracing::info!("{}", log);
        let _ = state.events.send(log);

        Ok(StatusCode::NO_CONTENT)
    } else {
        Err(StatusCode::NOT_FOUND)
    }
}

async fn list_orders(State(state): State<AppState>) -> Result<impl IntoResponse, StatusCode> {
    let orders = OrderRepository::list(&*state.pool, 100, 0)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    let responses: Vec<OrderResponse> = orders.into_iter().map(OrderResponse::from).collect();
    Ok(Json(responses))
}

async fn get_order(
    State(state): State<AppState>,
    Path(id): Path<Uuid>
) -> Result<impl IntoResponse, StatusCode> {
    let order = OrderRepository::find_by_id(&*state.pool, id)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
        .ok_or(StatusCode::NOT_FOUND)?;

    Ok(Json(OrderResponse::from(order)))
}

// ============================================================================
// Router Setup
// ============================================================================

fn app(state: AppState) -> Router {
    Router::new()
        .route("/orders", post(create_order).get(list_orders))
        .route(
            "/orders/{id}",
            get(get_order).patch(update_order).delete(delete_order)
        )
        .with_state(state)
}

// ============================================================================
// Main
// ============================================================================

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt()
        .with_env_filter("example_events=debug")
        .init();

    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgres://postgres:postgres@localhost:5432/entity_example".into());

    let pool = PgPool::connect(&database_url)
        .await
        .expect("Failed to connect to database");

    sqlx::migrate!("./migrations")
        .run(&pool)
        .await
        .expect("Failed to run migrations");

    let (tx, _rx) = broadcast::channel(100);

    let state = AppState {
        pool:   Arc::new(pool),
        events: tx
    };

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
    tracing::info!("Listening on http://localhost:3000");
    tracing::info!("Watch logs for [AUDIT] events");

    axum::serve(listener, app(state)).await.unwrap();
}
